---
title: Custom Components
---

## Code Structure

In short, ScrudBeans reads a package structure like the one bellow. 
At a minimum, ScrudBeans will process packages containing entity models and 
take a note of any optional, pre-existing custom components:

```
└── mypackage
    ├── controller
    │   └── OrderLineController.java
    └── dto
    │   └── OrderEmailUpdateDTO.java
    └── model
        ├── OrderLine.java
        ├── Order.java
        └── Product.java
```

To use your custom components, all you have to do is create them yourself - like the `OrderLineController` 
above. ScrudBeans will preserve any existing components and complete the structure needed for SCRUD as follows: 

```
└── mypackage
    ├── controller
    │   ├── OrderLineController.java
    │   ├── OrderController.java
    │   └── ProductController.java
    └── dto
    │   └── OrderEmailUpdateDTO.java
    └── mapper
    │   └── OrderToOrderEmailUpdateDTOMapper.java
    ├── model
    │   ├── OrderLine.java
    │   ├── Order.java
    │   └── Product.java
    ├── repository
    │   ├── OrderLineRepository.java
    │   ├── OrderRepository.java
    │   └── ProductRepository.java
    ├── service
    │   ├── OrderLineServiceImpl.java
    │   ├── OrderLineService.java
    │   ├── OrderServiceImpl.java
    │   ├── OrderService.java
    │   ├── ProductServiceImpl.java
    │   └── ProductService.java
    └── specification
        ├── AnyToOneOrderLinePredicateFactory.java
        ├── AnyToOneOrderPredicateFactory.java
        └── AnyToOneProductPredicateFactory.java
```

When using Maven, you can browse the generated component sources in `target/generated-sources/annotations`.

## Writing Components

ScrudBeans uses a 3-tier architecture with controllers, services and repositories to provide SCRUD services 
around each entity model. The following sections introduce the base components used by ScrudBeans and 
explain how those can be extended to make your own custom components if needed.

### Entity Models

Model driven services are enabled per entity provided two conditions are met:
 
 - It must be annotated with `@ScrudBean`.
 - It must implement `PersistableModel` or simply extend one of the abstract entities from the 
`com.github.manosbatsis.scrudbeans.jpa.model` package. 

To make this easier, ScrudBeans provides the `com.github.manosbatsis.scrudbeans.jpa.model` package, 
a set of mapped superclasses you can extend to create your entities.

#### UUID

To use automatically generated UUIDs as a primary key you can extend `AbstractSystemUuidPersistableModel`:

```java
@Entity
@Table(name = "products")
@ScrudBean
public class Product extends AbstractSystemUuidPersistableModel {/* ...*/ }
```

#### Auto Increment

You can auto-increment long IDs (i.e. `javax.persistence.GenerationType.AUTO`) you can extend
`AbstractAutoGeneratedLongIdPersistableModel`:

```java
@Entity
@Table(name = "discount_code")
@ScrudBean
public class DiscountCode extends AbstractAutoGeneratedLongIdPersistableModel {/* ...*/ }
```

#### Assigned IDs

To use assigned (i.e. manual) IDs, you can extend `AbstractAssignedIdPersistableModel`. It's generic, 
so you can specify the ID type required. e.g. for `Long`:

```java
@Entity 
@ScrudBean
@Table(name = "slot")
public class Slot extends AbstractAssignedIdPersistableModel<Long> {/* ...*/ }
```

You can use `@AttributeOverrides` to apply more specific restrictions, for example a string with a 
maximum length of two characters:

```java
@Entity 
@ScrudBean
@Table(name = "country")
@AttributeOverrides({
		@AttributeOverride(name = "id", column = @Column(unique = true, nullable = false, length = 2)),
})
public class Country extends AbstractAssignedIdPersistableModel<String> {/* ...*/ }
```

#### ManyToMany ID

Some times you need to assign additional attributes to a many-to-many relationship between models, 
for example the `Friendship` between two `User`s, along with the requirement of using the two foreign 
keys as the composite ID. This introduces some complexity in a number areas where the ID is handled, 
like JSON (de)serialization and request mapping bindings of path or query parameters.

For cases like these, you can easily create a mapping that "just works" in two steps. First, begin by  
extending `AbstractEmbeddableManyToManyIdentifier` to create a new `@Embeddable` ID type:
 

```java
@Embeddable
public class FriendshipIdentifier 
	extends AbstractEmbeddableManyToManyIdentifier<User, String, User, String> implements Serializable {

	@Override
	public User buildLeft(Serializable left) {
		User u = new User();
		u.setId(left.toString());
		return u;
	}

	@Override
	public User buildRight(Serializable right) {
		User u = new User();
		u.setId(right.toString());
		return u;
	}

}
```

Then, use the new identifier as the entity ID type of a `PersistableModel`:

```java
@Entity
@Table(name = "friendship")
@ScrudBean
public class Friendship implements PersistableModel<FriendshipIdentifier> {/* ...*/ }
```

### Repositories

To use your custom repository, all you have to do is create them e.g. like the `OrderLineRepository` bellow.

```
└── mypackage
    ├── repository
    │   └── OrderLineRepository.java
    └── model
        └── OrderLine.java
```

The implementation is actually a common Spring Data repository interface that extends 
`ModelRepository<ENTITY_TYPE, ID_TYPE>`:

```java
@Repository
public interface OrderLineRepository extends ModelRepository<OrderLine, String> {
	// Custom method!
    Optional<OrderLine> findOneByFoo(String foo);
}

```

### Services

To use your custom services, all you have to do is create them e.g. like the `OrderLineService` 

bellow.

```
└── mypackage
    ├── service
    │   └── OrderLineService.java
    └── model
        └── OrderLine.java
```

The service can either be a concrete class like: 

```java
public class OrderLineService  
	extends AbstractPersistableModelServiceImpl<OrderLine, String, OrderLineRepository>
	implements PersistableModelService<OrderLine, String> {
	// Custom methods...	
	Optional<OrderLine> findOneByFoo(String foo) {
		return this.repository.findOneByFoo(foo);
	}
	
}
```

or, if preferred, an interface and separate implementation:

```java
// For the interface, extend PersistableModelService<<ENTITY_TYPE, ID_TYPE>>
public interface OrderLineService 
	extends PersistableModelService<OrderLine, String> {
	//custom methods...	
	Optional<OrderLine> findOneByFoo(String foo);
}
	
// For the implementation, extend AbstractPersistableModelServiceImpl<<ENTITY_TYPE, ID_TYPE, REPO_TYPE>>
@Service("orderLineService")
public class OrderLineServiceImpl 
	extends AbstractPersistableModelServiceImpl<OrderLine, String, OrderLineRepository> 
	implements OrderLineService {
	// Custom methods...
	Optional<OrderLine> findOneByFoo(String foo) {
		return this.repository.findOneByFoo(foo);
	}
}
```

### Controllers

To use your custom controllers, create them yourself e.g. like the `OrderLineController` 
bellow.

```
└── mypackage
    ├── controller
    │   └── OrderLineController.java
    └── model
        └── OrderLine.java
```

The implementation can extend  
`AbstractPersistableModelController<ENTITY_TYPE, ID_TYPE, SERVICE_TYPE>`:

```java
@RestController("orderLineController")
@RequestMapping("/api/rest/orderLines")
@ExposesResourceFor(OrderLine.class)
public class OrderLineController 
extends AbstractPersistableModelController<OrderLine, String, OrderLineService> {
	// Custom methods...
	@GetMapping("foo/{foo}")
	public OrderLine findByFoo(@PathVariable String foo) {
		return this.service.findOneByFoo(foo).orElseThrow(() ->
			// Let scrudbeans-error create a 404 JSON response
			new NotFoundException("No match for foo: " + foo));
	}
}
```

### DTO Mappers

Most of the time, you can automatically generate [MapStruct](http://mapstruct.org/)-based mappers for your DTOs by 
adding those to your `@ScrudBean` `dtoTypes` or `dtoTypeNames` attributes like so:

```java
@ScrudBean(dtoTypes = {OrderUpdateEmailDTO.class}, dtoTypeNames = {"mypackage.dto.OrderUpdateCommentDTO"})
public class Order {
	//...
}
```

Sometimes however, you might want to edit the mappings your self by creating a custom mapper, 
like `OrderToOrderUpdateCommentDTOMapper` bellow:

```
└── mypackage
    ├── dto
    │   └── OrderUpdateCommentDTO.java
    ├── model
    │   └── Order.java
    └── mapper
        └── OrderToOrderUpdateCommentDTOMapper.java
```

The `OrderToOrderUpdateCommentDTOMapper` implementation can be a MapStruct-based interface that simply extends 
`DtoMapper<ENTITY_TYPE, DTO_TYPE>`:

```java
import com.github.manosbatsis.scrudbeans.api.DtoMapper;
import mypackage.dto.OrderUpdateCommentDTO;
import mypackage.model.Order;
import org.mapstruct.Mapper;

@Mapper(
    unmappedTargetPolicy = org.mapstruct.ReportingPolicy.IGNORE,
    componentModel = "spring"
)
public interface OrderToOrderUpdateCommentDTOMapper extends DtoMapper<Order, OrderUpdateCommentDTO> {
	// your custom mappings here...
}
```

MapStruct will pick up the interface and generate the actual implementation as usual.