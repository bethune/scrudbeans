---
title: Custom Components
---

## Code Structure

In short, ScrudBeans reads a package structure like the one bellow. 
At a minimum, ScrudBeans will process packages containing entity models and 
take a note of any optional, pre-existing custom components:

```
└── mypackage
    ├── controller
    │   └── OrderLineController.java
    └── model
        ├── OrderLine.java
        ├── Order.java
        └── Product.java
```

To use your custom components, all you have to do is create them yourself - like the `OrderLineController` 
above. ScrudBeans will preserve any existing components and complete the structure needed for SCRUD as follows: 

```
└── mypackage
    ├── controller
    │   ├── OrderLineController.java
    │   ├── OrderController.java
    │   └── ProductController.java
    ├── model
    │   ├── OrderLine.java
    │   ├── Order.java
    │   └── Product.java
    ├── repository
    │   ├── OrderLineRepository.java
    │   ├── OrderRepository.java
    │   └── ProductRepository.java
    ├── service
    │   ├── OrderLineServiceImpl.java
    │   ├── OrderLineService.java
    │   ├── OrderServiceImpl.java
    │   ├── OrderService.java
    │   ├── ProductServiceImpl.java
    │   └── ProductService.java
    └── specification
        ├── AnyToOneOrderLinePredicateFactory.java
        ├── AnyToOneOrderPredicateFactory.java
        └── AnyToOneProductPredicateFactory.java
```

When using Maven, you can browse the generated component sources in `target/generated-sources/annotations`.

## Base Components

ScrudBeans uses a 3-tier architecture with controllers, services and repositories to provide SCRUD services 
around each entity model. The following sections introduce the base components used by ScrudBeans and 
explain how those can be extended to make your own explicit custom components as needed.

### Entity Models

Model driven services are enabled per entity provided two conditions are met:
 
 - It must be annotated with `@ScrudBean`.
 - It must implement `PersistableModel` or simply extend one of the abstract entities from the 
`com.github.manosbatsis.scrudbeans.jpa.model` package. 

To make this easier, ScrudBeans provides the `com.github.manosbatsis.scrudbeans.jpa.model` package, 
a set of mapped superclasses you can extend to create your entities.

#### UUID

To use automatically generated UUIDs as a primary key you can extend `AbstractSystemUuidPersistableModel`:

```java
@Entity
@Table(name = "products")
@ScrudBean
public class Product extends AbstractSystemUuidPersistableModel {/* ...*/ }
```

#### Auto Increment

You can auto-increment long IDs (i.e. `javax.persistence.GenerationType.AUTO`) you can extend
`AbstractAutoGeneratedLongIdPersistableModel`:

```java
@Entity
@Table(name = "discount_code")
@ScrudBean
public class DiscountCode extends AbstractAutoGeneratedLongIdPersistableModel {/* ...*/ }
```

#### Assigned IDs

To use assigned (i.e. manual) IDs, you can extend `AbstractAssignedIdPersistableModel`. It's generic, 
so you can specify the ID type required. e.g. for `Long`:

```java
@Entity 
@ScrudBean
@Table(name = "slot")
public class Slot extends AbstractAssignedIdPersistableModel<Long> {/* ...*/ }
```

You can use `@AttributeOverrides` to apply more specific restrictions, for example a string with a 
maximum length of two characters:

```java
@Entity 
@ScrudBean
@Table(name = "country")
@AttributeOverrides({
		@AttributeOverride(name = "id", column = @Column(unique = true, nullable = false, length = 2)),
})
public class Country extends AbstractAssignedIdPersistableModel<String> {/* ...*/ }
```

#### ManyToMany ID

Some times you need to assign additional attributes to a many-to-many relationship between models, 
for example the `Friendship` between two `User`s, along with the requirement of using the two foreign 
keys as the composite ID. This introduces some complexity in a number areas where the ID is handled, 
like JSON (de)serialization and request mapping bindings of path or query parameters.

For cases like these, you can easily create a mapping that "just works" in two steps. First, begin by  
extending `AbstractEmbeddableManyToManyIdentifier` to create a new `@Embeddable` ID type:
 

```java
@Embeddable
public class FriendshipIdentifier 
	extends AbstractEmbeddableManyToManyIdentifier<User, String, User, String> implements Serializable {

	@Override
	public User buildLeft(Serializable left) {
		User u = new User();
		u.setId(left.toString());
		return u;
	}

	@Override
	public User buildRight(Serializable right) {
		User u = new User();
		u.setId(right.toString());
		return u;
	}

}
```

Then, use the new identifier as the entity ID type of a `PersistableModel`:

```java
@Entity
@Table(name = "friendship")
@ScrudBean
public class Friendship implements PersistableModel<FriendshipIdentifier> {/* ...*/ }
```

### Repositories

To use your custom repository, all you have to do is create them e.g. like the `OrderLineRepository` bellow.

```
└── mypackage
    ├── repository
    │   └── OrderLineRepository.java
    └── model
        ├── OrderLine.java
        ├── Order.java
        └── Product.java
```

The implementation is actually a common Spring Data repository interface that extends 
`ModelRepository<ENTITY_TYPE, ID_TYPE>`:

```java

@Repository
public interface OrderLineRepository extends ModelRepository<OrderLine, String> {
	// Custom method!
    OrderLine findByFoo(String foo);
}

```

### Services

To use your custom services, all you have to do is create them e.g. like the `OrderLineService` 

bellow.

```
└── mypackage
    ├── service
    │   └── OrderLineService.java
    └── model
        ├── OrderLine.java
        ├── Order.java
        └── Product.java
```

The service can either be a concrete class like: 

```java
public class OrderLineService  
	// either ModelRepository<OrderLine, String> or simply OrderLineRepository
	extends AbstractPersistableModelServiceImpl<OrderLine, String, ModelRepository<OrderLine, String>>
	implements PersistableModelService<OrderLine, String> {
	//custom methods...	
}
```

or, if preferred, an interface and separate implementation:

```java
// For the interface, extend PersistableModelService<<ENTITY_TYPE, ID_TYPE>>
public interface OrderLineService 
	extends PersistableModelService<OrderLine, String> {
	//custom methods...	
}
	
// For the implementation, extend AbstractPersistableModelServiceImpl<<ENTITY_TYPE, ID_TYPE, REPO_TYPE>>
@Service("orderLineService")
public class OrderLineServiceImpl 
	extends AbstractPersistableModelServiceImpl<OrderLine, String, OrderLineRepository> 
	implements OrderLineService {
	//custom methods...
}
```

### Controllers

To use your custom controllers, create them yourself e.g. like the `OrderLineController` 
bellow.

```
└── mypackage
    ├── controller
    │   └── OrderLineController.java
    └── model
        ├── OrderLine.java
        ├── Order.java
        └── Product.java
```

The implementation can extend  
`AbstractPersistableModelController<ENTITY_TYPE, ID_TYPE, SERVICE_TYPE>`:

```java
@RestController("orderLineController")
@RequestMapping("/api/rest/orderLines")
@ExposesResourceFor(OrderLine.class)
public class OrderLineController extends AbstractPersistableModelController<OrderLine, String, OrderLineService> {
	//custom methods...
}
```
